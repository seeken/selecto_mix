defmodule SelectoMix.GuideGenerator do
  @moduledoc """
  Generates comprehensive guides for Selecto development, migration, and best practices.
  """

  @doc """
  Generate guides index page.
  """
  def generate_guides_index(guide_types, format \\ :markdown) do
    case format do
      :markdown -> generate_markdown_guides_index(guide_types)
      :html -> generate_html_guides_index(guide_types)
    end
  end

  @doc """
  Generate specific guide content.
  """
  def generate_guide(guide_type, format \\ :markdown, opts \\ []) do
    case format do
      :markdown -> generate_markdown_guide(guide_type, opts)
      :html -> generate_html_guide(guide_type, opts)
    end
  end

  # Private functions for markdown generation

  defp generate_markdown_guides_index(guide_types) do
    """
    # Selecto Guides

    Welcome to the comprehensive guide collection for the Selecto ecosystem. These guides
    provide detailed information for developers working with Selecto at all experience levels.

    ## Getting Started

    New to Selecto? Start with these essential guides:

    #{generate_guide_links(guide_types, ["getting-started", "best-practices"])}

    ## Development Guides

    #{generate_guide_links(guide_types, ["testing", "performance", "advanced"])}

    ## Operations & Deployment

    #{generate_guide_links(guide_types, ["deployment", "troubleshooting", "migration"])}

    ## Guide Overview

    #{generate_all_guides_overview(guide_types)}

    ## Additional Resources

    - [API Reference](../api/) - Complete API documentation
    - [Domain Documentation](../selecto/) - Generated domain-specific guides
    - [Examples Repository](https://github.com/your-org/selecto-examples) - Real-world examples
    - [Community Forum](https://forum.selecto.dev) - Ask questions and share knowledge

    ## Contributing to Documentation

    Found an error or want to improve these guides? We welcome contributions!

    1. Fork the repository
    2. Make your changes
    3. Test with `mix selecto.docs.guide --dry-run`
    4. Submit a pull request

    ---

    *Generated by `mix selecto.docs.guide`*
    """
  end

  defp generate_guide_links(guide_types, filter_types) do
    guide_types
    |> Enum.filter(&(&1 in filter_types))
    |> Enum.map(&format_guide_link/1)
    |> case do
      [] -> "*No guides available in this category*"
      links -> Enum.join(links, "\n")
    end
  end

  defp format_guide_link(guide_type) do
    title = format_guide_title(guide_type)
    description = get_guide_description(guide_type)
    "- [#{title}](#{guide_type}.md) - #{description}"
  end

  defp format_guide_title(guide_type) do
    guide_type
    |> String.split("-")
    |> Enum.map(&String.capitalize/1)
    |> Enum.join(" ")
  end

  defp get_guide_description(guide_type) do
    case guide_type do
      "getting-started" -> "Complete tutorial for new Selecto developers"
      "migration" -> "Guide for migrating between Selecto versions"
      "best-practices" -> "Recommended patterns and development practices"
      "troubleshooting" -> "Solutions for common issues and problems"
      "performance" -> "Optimization strategies and performance tuning"
      "testing" -> "Testing strategies and examples for Selecto applications"
      "deployment" -> "Production deployment and configuration guides"
      "advanced" -> "Advanced usage patterns and expert techniques"
      _ -> "Comprehensive guide for Selecto development"
    end
  end

  defp generate_all_guides_overview(guide_types) do
    guide_types
    |> Enum.map(fn guide_type ->
      title = format_guide_title(guide_type)
      description = get_guide_description(guide_type)
      
      """
      ### #{title}
      
      #{description}
      
      [Read the #{title} guide â†’](#{guide_type}.md)
      """
    end)
    |> Enum.join("\n")
  end

  defp generate_markdown_guide(guide_type, opts) do
    case guide_type do
      "getting-started" -> generate_getting_started_guide(opts)
      "migration" -> generate_migration_guide(opts)
      "best-practices" -> generate_best_practices_guide(opts)
      "troubleshooting" -> generate_troubleshooting_guide(opts)
      "performance" -> generate_performance_guide(opts)
      "testing" -> generate_testing_guide(opts)
      "deployment" -> generate_deployment_guide(opts)
      "advanced" -> generate_advanced_guide(opts)
      _ -> generate_generic_guide(guide_type, opts)
    end
  end

  defp generate_getting_started_guide(_opts) do
    """
    # Getting Started with Selecto

    Welcome to Selecto! This guide will help you get up and running with the Selecto ecosystem
    for building dynamic data interfaces in Phoenix LiveView applications.

    ## What is Selecto?

    Selecto is a comprehensive toolkit for building data-driven applications with Phoenix LiveView:

    - **Core Query Builder**: Advanced SQL query building with joins, CTEs, and OLAP functions
    - **LiveView Components**: Interactive data visualization components
    - **Domain Configuration**: Rich metadata-driven data modeling
    - **Performance Tools**: Query optimization and monitoring capabilities

    ## Installation

    ### 1. Add Dependencies

    Add Selecto to your `mix.exs` dependencies:

    ```elixir
    defp deps do
      [
        {:selecto, "~> 0.2.6"},
        {:selecto_components, "~> 0.2.8"},
        # Optional: For interactive development
        {:selecto_kino, "~> 0.1.0"},
        # Your existing dependencies...
      ]
    end
    ```

    ### 2. Install Dependencies

    ```bash
    mix deps.get
    ```

    ### 3. Configure Database

    Ensure your database configuration is set up in `config/config.exs`:

    ```elixir
    config :my_app, MyApp.Repo,
      username: "postgres",
      password: "postgres",
      hostname: "localhost",
      database: "my_app_dev",
      port: 5432
    ```

    ## Your First Domain

    ### 1. Generate Domain Configuration

    Use the Mix task to generate domain configuration from your existing Ecto schemas:

    ```bash
    mix selecto.gen.domain Blog.Post --include-associations
    ```

    This creates a domain configuration file that describes your data structure.

    ### 2. Configure Your LiveView

    Add Selecto components to your LiveView:

    ```elixir
    defmodule MyAppWeb.PostsLive do
      use MyAppWeb, :live_view
      
      def mount(_params, _session, socket) do
        {:ok, assign(socket, db_connection: MyApp.Repo)}
      end
      
      def render(assigns) do
        ~H\"\"\"
        <div>
          <.live_component 
            module={SelectoComponents.Form} 
            id="posts-data"
            domain={posts_domain()}
            connection={@db_connection}
          />
        </div>
        \"\"\"
      end
      
      defp posts_domain do
        # Your generated domain configuration
        MyApp.PostsDomain.posts_domain()
      end
    end
    ```

    ### 3. Add Routes

    Add the route to your router:

    ```elixir
    # In lib/my_app_web/router.ex
    scope "/", MyAppWeb do
      pipe_through :browser
      
      live "/posts", PostsLive
    end
    ```

    ## Core Concepts

    ### Domain Configuration

    Domains describe your data structure and relationships:

    ```elixir
    def posts_domain do
      %{
        source: %{
          source_table: "posts",
          primary_key: :id,
          fields: [:id, :title, :content, :published_at],
          columns: %{
            id: %{type: :integer},
            title: %{type: :string},
            content: %{type: :text},
            published_at: %{type: :datetime}
          }
        },
        schemas: %{
          # Related schemas and joins
        }
      }
    end
    ```

    ### Query Building

    Build queries programmatically:

    ```elixir
    # Basic selection
    posts = Selecto.select(posts_domain(), [:id, :title])
    |> Selecto.filter(:published_at, :is_not_null, nil)
    |> Selecto.order_by([{:published_at, :desc}])
    |> Selecto.limit(10)
    |> Selecto.execute(MyApp.Repo)

    # Aggregation
    stats = Selecto.select(posts_domain(), [:status, :count])
    |> Selecto.group_by([:status])
    |> Selecto.aggregate(:count, :id)
    |> Selecto.execute(MyApp.Repo)
    ```

    ### Interactive Components

    Use LiveView components for interactive data exploration:

    ```elixir
    # Aggregate view with drill-down
    <.live_component 
      module={SelectoComponents.Aggregate} 
      id="posts-aggregate"
      domain={posts_domain()}
      connection={@db_connection}
      initial_fields={[:status, :author]}
      initial_aggregates={[:count, :avg_views]}
    />

    # Detail view with filtering
    <.live_component 
      module={SelectoComponents.Detail} 
      id="posts-detail"
      domain={posts_domain()}
      connection={@db_connection}
      filters={@current_filters}
    />
    ```

    ## Next Steps

    ### Explore Advanced Features

    1. **Joins and Relationships**: Learn how to work with complex data relationships
    2. **Performance Optimization**: Understand indexing and query optimization
    3. **Custom Components**: Build your own data visualization components
    4. **Testing**: Write comprehensive tests for your data interfaces

    ### Recommended Reading

    - [Best Practices Guide](best-practices.md) - Development patterns and recommendations
    - [API Reference](../api/) - Complete function documentation
    - [Performance Guide](performance.md) - Optimization strategies

    ### Community Resources

    - [GitHub Repository](https://github.com/your-org/selecto) - Source code and issue tracking
    - [Examples Repository](https://github.com/your-org/selecto-examples) - Real-world examples
    - [Community Forum](https://forum.selecto.dev) - Ask questions and share knowledge

    ## Troubleshooting

    ### Common Issues

    **Module not found errors**
    ```
    ** (UndefinedFunctionError) function MyApp.PostsDomain.posts_domain/0 is undefined
    ```
    
    Make sure you've generated the domain configuration and it's in the correct location.

    **Database connection errors**
    ```
    ** (DBConnection.ConnectionError) connection not available
    ```
    
    Verify your database configuration and ensure the database is running.

    **Asset compilation errors**

    Ensure you've added the necessary JavaScript dependencies for SelectoComponents.

    For more detailed troubleshooting, see the [Troubleshooting Guide](troubleshooting.md).

    ---

    *Generated by `mix selecto.docs.guide`*
    """
  end

  defp generate_migration_guide(opts) do
    from_version = opts[:from_version] || "0.1.x"
    to_version = opts[:to_version] || "0.2.x"
    
    """
    # Migration Guide: #{from_version} â†’ #{to_version}

    This guide helps you migrate your Selecto application from version #{from_version} to #{to_version}.

    ## Breaking Changes

    ### Domain Configuration Format

    **Before (#{from_version}):**
    ```elixir
    def my_domain do
      %{
        table: "posts",
        fields: [:id, :title],
        # Old format
      }
    end
    ```

    **After (#{to_version}):**
    ```elixir
    def my_domain do
      %{
        source: %{
          source_table: "posts",
          primary_key: :id,
          fields: [:id, :title],
          columns: %{
            id: %{type: :integer},
            title: %{type: :string}
          }
        }
      }
    end
    ```

    ### Component API Changes

    **Before (#{from_version}):**
    ```elixir
    <.live_component 
      module={SelectoComponents.DataView}
      domain={my_domain()}
    />
    ```

    **After (#{to_version}):**
    ```elixir
    <.live_component 
      module={SelectoComponents.Form}
      id="unique-id"
      domain={my_domain()}
      connection={@db_connection}
    />
    ```

    ## Migration Steps

    ### 1. Update Dependencies

    Update your `mix.exs`:

    ```elixir
    defp deps do
      [
        {:selecto, "~> #{to_version}"},
        {:selecto_components, "~> #{to_version}"},
        # ...
      ]
    end
    ```

    ### 2. Regenerate Domain Configurations

    Use the updated domain generation:

    ```bash
    # Backup existing configurations
    cp -r lib/my_app/domains lib/my_app/domains.backup

    # Generate new configurations
    mix selecto.gen.domain --all --force
    ```

    ### 3. Update Component Usage

    Update your LiveView templates to use the new component API:

    ```elixir
    # Add required assigns
    def mount(_params, _session, socket) do
      {:ok, assign(socket, db_connection: MyApp.Repo)}
    end
    ```

    ### 4. Test Migration

    Run your test suite to ensure everything works:

    ```bash
    mix test
    ```

    ## Automated Migration

    Use the automated migration tool:

    ```bash
    mix selecto.migrate --from=#{from_version} --to=#{to_version}
    ```

    This will:
    - Analyze your existing code
    - Generate migration recommendations
    - Update domain configurations
    - Provide a migration report

    ## New Features in #{to_version}

    ### Enhanced Query Builder

    - Support for CTEs and window functions
    - Improved join performance
    - Better error messages

    ### Advanced Components

    - Graph visualization components
    - Enhanced filtering interface
    - Drill-down navigation

    ### Performance Improvements

    - Connection pooling
    - Query result caching
    - Optimized rendering

    ## Troubleshooting Migration

    ### Common Migration Issues

    **Domain configuration errors**

    If you see errors like:
    ```
    ** (KeyError) key :source not found
    ```

    Make sure you've updated your domain configuration format.

    **Component rendering errors**

    Ensure you're passing the required `id` and `connection` props to components.

    **Performance regressions**

    Check the [Performance Guide](performance.md) for optimization strategies.

    ## Getting Help

    If you encounter issues during migration:

    1. Check the [Troubleshooting Guide](troubleshooting.md)
    2. Search existing [GitHub issues](https://github.com/your-org/selecto/issues)
    3. Ask on the [Community Forum](https://forum.selecto.dev)
    4. Create a new issue with your migration details

    ## Post-Migration Checklist

    - [ ] All tests pass
    - [ ] Domain configurations are updated
    - [ ] Components render correctly
    - [ ] Performance is acceptable
    - [ ] Documentation is updated
    - [ ] Team is trained on changes

    ---

    *Generated by `mix selecto.docs.guide`*
    """
  end

  defp generate_best_practices_guide(_opts) do
    """
    # Selecto Best Practices

    This guide outlines recommended practices for building robust, maintainable, and performant
    applications with the Selecto ecosystem.

    ## Domain Design

    ### Structure Your Domains Logically

    **Good:** Organize domains by business context
    ```elixir
    # lib/my_app/domains/
    # â”œâ”€â”€ blog_domain.ex          # Blog-related entities
    # â”œâ”€â”€ user_management_domain.ex # User entities
    # â””â”€â”€ analytics_domain.ex     # Analytics data
    ```

    **Avoid:** Mixing unrelated entities in one domain
    ```elixir
    # Don't put users, posts, and analytics in one domain
    ```

    ### Use Descriptive Field Names

    **Good:**
    ```elixir
    fields: [:id, :title, :content, :published_at, :author_id]
    ```

    **Avoid:**
    ```elixir
    fields: [:id, :t, :c, :pub, :uid]  # Cryptic names
    ```

    ### Include Proper Type Information

    **Good:**
    ```elixir
    columns: %{
      id: %{type: :integer, primary_key: true},
      title: %{type: :string, max_length: 255},
      content: %{type: :text},
      published_at: %{type: :datetime, nullable: true}
    }
    ```

    ## Query Building

    ### Build Queries Incrementally

    **Good:**
    ```elixir
    def get_published_posts(filters \\\\ %{}) do
      posts_domain()
      |> Selecto.select([:id, :title, :published_at])
      |> Selecto.filter(:published_at, :is_not_null, nil)
      |> maybe_filter_by_author(filters[:author_id])
      |> maybe_filter_by_category(filters[:category_id])
      |> Selecto.order_by([{:published_at, :desc}])
      |> Selecto.limit(50)
    end

    defp maybe_filter_by_author(query, nil), do: query
    defp maybe_filter_by_author(query, author_id) do
      Selecto.filter(query, :author_id, :eq, author_id)
    end
    ```

    **Avoid:** Monolithic query functions
    ```elixir
    def complex_query_with_everything(many, different, parameters) do
      # Hundreds of lines of query building...
    end
    ```

    ### Use Proper Error Handling

    **Good:**
    ```elixir
    def safe_execute_query(query) do
      try do
        case Selecto.execute(query, MyApp.Repo) do
          results when is_list(results) -> {:ok, results}
          _ -> {:error, :unexpected_result}
        end
      rescue
        e in [Ecto.Query.CastError] ->
          {:error, {:invalid_query, e.message}}
        e ->
          Logger.error("Query execution failed: \#{inspect(e)}")
          {:error, :database_error}
      end
    end
    ```

    ### Optimize Query Performance

    **Good:**
    ```elixir
    # Select only needed fields
    Selecto.select(domain, [:id, :title])

    # Use appropriate indexes
    |> Selecto.filter(:status, :eq, "published")  # Indexed field

    # Limit result sets
    |> Selecto.limit(25)
    ```

    **Avoid:**
    ```elixir
    # Selecting all fields unnecessarily
    Selecto.select(domain, :all)

    # No limits on large datasets
    |> Selecto.execute(MyApp.Repo)  # Could return millions of rows
    ```

    ## LiveView Integration

    ### Component Organization

    **Good:** Use specific components for specific purposes
    ```elixir
    <div class="data-dashboard">
      <.live_component 
        module={SelectoComponents.Aggregate} 
        id="summary-stats"
        domain={posts_domain()}
        connection={@db_connection}
        initial_fields={[:status]}
        initial_aggregates={[:count]}
      />
      
      <.live_component 
        module={SelectoComponents.Detail} 
        id="posts-detail"
        domain={posts_domain()}
        connection={@db_connection}
        filters={@filters}
        on_row_click={&handle_post_selected/1}
      />
    </div>
    ```

    ### State Management

    **Good:** Keep state minimal and focused
    ```elixir
    defmodule MyAppWeb.PostsLive do
      def mount(_params, _session, socket) do
        socket = 
          socket
          |> assign(db_connection: MyApp.Repo)
          |> assign(filters: %{})
          |> assign(selected_post: nil)
        
        {:ok, socket}
      end

      def handle_event("filter_changed", filters, socket) do
        {:noreply, assign(socket, filters: filters)}
      end
    end
    ```

    **Avoid:** Storing redundant or derived state
    ```elixir
    # Don't store data that can be computed
    assign(socket, 
      posts: posts,
      post_count: length(posts),  # Derived
      has_posts: posts != []      # Derived
    )
    ```

    ## Performance

    ### Database Optimization

    **Index Strategy:**
    ```sql
    -- Index frequently filtered fields
    CREATE INDEX idx_posts_status ON posts (status);
    CREATE INDEX idx_posts_published_at ON posts (published_at);

    -- Composite indexes for multiple filters
    CREATE INDEX idx_posts_status_date ON posts (status, published_at);

    -- Foreign keys for joins
    CREATE INDEX idx_posts_author_id ON posts (author_id);
    ```

    **Query Optimization:**
    ```elixir
    # Good: Use appropriate limits
    def get_recent_posts do
      posts_domain()
      |> Selecto.select([:id, :title, :published_at])
      |> Selecto.filter(:published_at, :gte, Date.add(Date.utc_today(), -30))
      |> Selecto.order_by([{:published_at, :desc}])
      |> Selecto.limit(100)  # Reasonable limit
      |> Selecto.execute(MyApp.Repo)
    end
    ```

    ### Component Performance

    **Good:** Use pagination for large datasets
    ```elixir
    <.live_component 
      module={SelectoComponents.Detail} 
      id="posts-detail"
      domain={posts_domain()}
      connection={@db_connection}
      page_size={25}
      enable_pagination={true}
    />
    ```

    **Memory Management:**
    ```elixir
    # Stream large result sets
    def process_all_posts do
      posts_domain()
      |> Selecto.select([:id, :content])
      |> Selecto.stream(MyApp.Repo, max_rows: 1000)
      |> Stream.map(&process_post/1)
      |> Stream.run()
    end
    ```

    ## Testing

    ### Unit Testing Domains

    **Good:**
    ```elixir
    defmodule MyApp.PostsDomainTest do
      use MyApp.DataCase
      
      describe "posts_domain/0" do
        test "includes all required fields" do
          domain = MyApp.PostsDomain.posts_domain()
          
          assert domain.source.source_table == "posts"
          assert :id in domain.source.fields
          assert :title in domain.source.fields
        end
      end
      
      describe "query building" do
        test "filters published posts correctly" do
          insert(:post, published_at: DateTime.utc_now())
          insert(:post, published_at: nil)
          
          query = build_published_posts_query()
          results = Selecto.execute(query, MyApp.Repo)
          
          assert length(results) == 1
        end
      end
    end
    ```

    ### Integration Testing Components

    **Good:**
    ```elixir
    defmodule MyAppWeb.PostsLiveTest do
      use MyAppWeb.ConnCase
      import Phoenix.LiveViewTest
      
      test "displays posts correctly", %{conn: conn} do
        post = insert(:post, title: "Test Post")
        
        {:ok, view, html} = live(conn, "/posts")
        
        assert html =~ "Test Post"
        assert has_element?(view, "[data-testid='posts-table']")
      end
    end
    ```

    ## Security

    ### Input Validation

    **Good:**
    ```elixir
    def safe_filter_posts(filter_params) do
      with :ok <- validate_filter_params(filter_params),
           :ok <- validate_user_permissions(filter_params) do
        build_posts_query(filter_params)
      end
    end
    
    defp validate_filter_params(params) do
      allowed_fields = [:title, :status, :published_at]
      
      case Map.keys(params) -- allowed_fields do
        [] -> :ok
        invalid_fields -> {:error, {:invalid_fields, invalid_fields}}
      end
    end
    ```

    ### Access Control

    **Good:**
    ```elixir
    def mount(_params, %{"user_id" => user_id}, socket) do
      if authorized_user?(user_id) do
        {:ok, assign(socket, user_id: user_id)}
      else
        {:error, :unauthorized}
      end
    end
    ```

    ## Documentation

    ### Document Domain Configurations

    **Good:**
    ```elixir
    @doc \"\"\"
    Posts domain configuration for blog content management.
    
    This domain includes:
    - Main posts table with content and metadata
    - Author relationships through users table
    - Category associations for organization
    - Publishing workflow fields
    
    ## Example Usage
    
        posts_domain()
        |> Selecto.select([:id, :title])
        |> Selecto.filter(:status, :eq, "published")
    \"\"\"
    def posts_domain do
      # Domain configuration...
    end
    ```

    ### Add Function Documentation

    **Good:**
    ```elixir
    @doc \"\"\"
    Builds a query for recently published posts.
    
    Returns posts published within the specified number of days,
    ordered by publication date (most recent first).
    
    ## Parameters
    
    - `days` - Number of days to look back (default: 7)
    - `limit` - Maximum number of posts to return (default: 50)
    
    ## Examples
    
        get_recent_posts()
        #=> [%{id: 1, title: "Recent Post", ...}]
        
        get_recent_posts(days: 30, limit: 10)
    \"\"\"
    def get_recent_posts(opts \\\\ []) do
      # Implementation...
    end
    ```

    ## Error Handling

    ### Graceful Degradation

    **Good:**
    ```elixir
    def handle_event("load_data", _params, socket) do
      case load_posts_data() do
        {:ok, posts} -> 
          {:noreply, assign(socket, posts: posts, error: nil)}
        {:error, reason} ->
          Logger.warn("Failed to load posts: \#{inspect(reason)}")
          {:noreply, assign(socket, error: "Unable to load data")}
      end
    end
    ```

    ### User-Friendly Error Messages

    **Good:**
    ```elixir
    defp format_error({:database_error, _details}) do
      "We're having trouble connecting to the database. Please try again."
    end
    
    defp format_error({:invalid_filter, field}) do
      "The filter for '\#{field}' is not valid. Please check your input."
    end
    ```

    ## Monitoring and Observability

    ### Add Telemetry

    **Good:**
    ```elixir
    def execute_query(query) do
      start_time = System.monotonic_time()
      
      try do
        result = Selecto.execute(query, MyApp.Repo)
        duration = System.monotonic_time() - start_time
        
        :telemetry.execute([:selecto, :query, :success], %{
          duration: duration,
          result_count: length(result)
        })
        
        {:ok, result}
      rescue
        e ->
          duration = System.monotonic_time() - start_time
          
          :telemetry.execute([:selecto, :query, :error], %{
            duration: duration
          }, %{error: inspect(e)})
          
          {:error, e}
      end
    end
    ```

    ## Deployment

    ### Environment Configuration

    **Good:**
    ```elixir
    # config/runtime.exs
    config :my_app, MyApp.Repo,
      pool_size: String.to_integer(System.get_env("DATABASE_POOL_SIZE") || "20"),
      queue_target: String.to_integer(System.get_env("DATABASE_QUEUE_TARGET") || "50")
    ```

    ### Health Checks

    **Good:**
    ```elixir
    def health_check do
      try do
        # Test basic query functionality
        test_domain()
        |> Selecto.select([:count])
        |> Selecto.aggregate(:count, :id)
        |> Selecto.execute(MyApp.Repo)
        
        :ok
      rescue
        _ -> :error
      end
    end
    ```

    ---

    *Generated by `mix selecto.docs.guide`*
    """
  end

  defp generate_troubleshooting_guide(_opts) do
    """
    # Troubleshooting Guide

    This guide helps you diagnose and resolve common issues when working with Selecto.

    ## Installation Issues

    ### Dependency Resolution Errors

    **Problem:**
    ```
    ** (Mix) Could not resolve dependency selecto
    ```

    **Solutions:**
    1. Check that you're using compatible versions:
       ```elixir
       {:selecto, "~> 0.2.6"},
       {:selecto_components, "~> 0.2.8"}
       ```
    2. Clear dependency cache: `mix deps.clean --all && mix deps.get`
    3. Check for conflicting dependencies: `mix deps.tree`

    ### Compilation Errors

    **Problem:**
    ```
    ** (CompileError) lib/my_app/domains/posts_domain.ex:15: undefined function posts_domain/0
    ```

    **Solutions:**
    1. Ensure domain files are in the correct location
    2. Check module naming conventions
    3. Verify the domain configuration syntax

    ## Database Connection Issues

    ### Connection Refused

    **Problem:**
    ```
    ** (DBConnection.ConnectionError) connection not available and request was dropped from queue after 5000ms
    ```

    **Solutions:**
    1. Verify database is running: `psql -h localhost -U postgres -c "SELECT 1;"`
    2. Check connection configuration in `config/dev.exs`
    3. Increase pool size if needed:
       ```elixir
       config :my_app, MyApp.Repo,
         pool_size: 20
       ```

    ### Invalid Query Errors

    **Problem:**
    ```
    ** (Postgrex.Error) ERROR 42703 (undefined_column) column "invalid_field" does not exist
    ```

    **Solutions:**
    1. Check that field names match database columns exactly
    2. Verify domain configuration includes all required fields
    3. Run database migrations: `mix ecto.migrate`

    ## Domain Configuration Issues

    ### Module Not Found

    **Problem:**
    ```
    ** (UndefinedFunctionError) function MyApp.PostsDomain.posts_domain/0 is undefined
    ```

    **Solutions:**
    1. Generate domain configuration: `mix selecto.gen.domain Blog.Post`
    2. Ensure the module is defined correctly:
       ```elixir
       defmodule MyApp.PostsDomain do
         def posts_domain do
           # Configuration...
         end
       end
       ```
    3. Check module is compiled: `mix compile`

    ### Invalid Domain Structure

    **Problem:**
    ```
    ** (KeyError) key :source not found in: %{table: "posts", ...}
    ```

    **Solutions:**
    1. Update to new domain format:
       ```elixir
       # Old format
       %{table: "posts"}
       
       # New format  
       %{
         source: %{
           source_table: "posts",
           primary_key: :id
         }
       }
       ```

    ## LiveView Component Issues

    ### Component Not Rendering

    **Problem:**
    Component shows blank or throws errors during rendering.

    **Solutions:**
    1. Check required assigns are provided:
       ```elixir
       <.live_component 
         module={SelectoComponents.Form}
         id="unique-id"           # Required
         domain={domain()}        # Required
         connection={@db_connection}  # Required
       />
       ```
    2. Ensure assets are compiled: `mix assets.build`
    3. Check browser console for JavaScript errors

    ### JavaScript Errors

    **Problem:**
    ```
    Uncaught TypeError: Cannot read properties of undefined (reading 'hooks')
    ```

    **Solutions:**
    1. Ensure Phoenix LiveView JavaScript is loaded
    2. Check asset compilation: `mix assets.deploy`
    3. Verify SelectoComponents hooks are registered:
       ```javascript
       import {Socket} from "phoenix"
       import {LiveSocket} from "phoenix_live_view"
       import SelectoComponentsHooks from "selecto_components"

       let liveSocket = new LiveSocket("/live", Socket, {
         hooks: {...SelectoComponentsHooks}
       })
       ```

    ## Performance Issues

    ### Slow Query Performance

    **Problem:**
    Queries taking longer than expected to execute.

    **Diagnosis:**
    1. Enable query logging:
       ```elixir
       config :my_app, MyApp.Repo,
         log: :debug
       ```
    2. Use `EXPLAIN ANALYZE` in database console
    3. Check for missing indexes

    **Solutions:**
    1. Add appropriate indexes:
       ```sql
       CREATE INDEX idx_posts_status ON posts (status);
       CREATE INDEX idx_posts_published_at ON posts (published_at);
       ```
    2. Limit result sets:
       ```elixir
       |> Selecto.limit(50)
       ```
    3. Select only needed fields:
       ```elixir
       Selecto.select(domain, [:id, :title])  # Not :all
       ```

    ### Memory Usage Issues

    **Problem:**
    High memory consumption or out-of-memory errors.

    **Solutions:**
    1. Use streaming for large datasets:
       ```elixir
       domain
       |> Selecto.select([:id, :data])
       |> Selecto.stream(MyApp.Repo, max_rows: 1000)
       |> Stream.map(&process_row/1)
       ```
    2. Implement pagination:
       ```elixir
       |> Selecto.limit(25)
       |> Selecto.offset(page * 25)
       ```
    3. Check for data leaks in LiveView processes

    ## Common Error Patterns

    ### Type Conversion Errors

    **Problem:**
    ```
    ** (Ecto.Query.CastError) lib/ecto/repo/queryable.ex:413: value `"invalid"` in `where` cannot be cast to type :integer
    ```

    **Solutions:**
    1. Validate input before querying:
       ```elixir
       defp validate_id(id) when is_binary(id) do
         case Integer.parse(id) do
           {int_id, ""} -> {:ok, int_id}
           _ -> {:error, :invalid_id}
         end
       end
       ```
    2. Use appropriate filter operators for data types

    ### Association Loading Errors

    **Problem:**
    ```
    ** (Ecto.Association.NotLoaded) association `:author` is not loaded
    ```

    **Solutions:**
    1. Use proper joins instead of preloads:
       ```elixir
       domain
       |> Selecto.select([:id, :title, "authors.name as author_name"])
       |> Selecto.join(:inner, :authors, :author_id, :id)
       ```
    2. Configure associations in domain properly

    ## Development Tools

    ### Enable Debug Logging

    ```elixir
    # config/dev.exs
    config :logger, level: :debug

    config :my_app, MyApp.Repo,
      log: :debug,
      stacktrace: true
    ```

    ### Use IEx for Debugging

    ```elixir
    # In your code
    require IEx; IEx.pry

    # Then in IEx:
    iex> query = posts_domain() |> Selecto.select([:id, :title])
    iex> IO.inspect(Selecto.to_sql(query))
    ```

    ### Database Query Analysis

    ```sql
    -- Enable query logging
    ALTER SYSTEM SET log_statement = 'all';
    SELECT pg_reload_conf();

    -- Analyze specific queries
    EXPLAIN (ANALYZE, BUFFERS) 
    SELECT id, title FROM posts WHERE status = 'published';
    ```

    ## Getting Help

    ### Before Asking for Help

    1. **Check the logs**: Look for specific error messages
    2. **Reproduce the issue**: Create minimal reproduction case
    3. **Check documentation**: Review relevant guides and API docs
    4. **Search existing issues**: Check GitHub issues for similar problems

    ### Creating a Good Bug Report

    Include the following information:

    ```
    **Environment:**
    - Elixir version: (elixir --version)
    - Phoenix version: (mix deps | grep phoenix)
    - Selecto version: (mix deps | grep selecto)
    - Database: PostgreSQL X.X

    **Error Message:**
    (paste full error message and stacktrace)

    **Minimal Reproduction:**
    (code that reproduces the issue)

    **Expected Behavior:**
    (what you expected to happen)

    **Actual Behavior:**
    (what actually happened)
    ```

    ### Where to Get Help

    1. **Documentation**: Check the comprehensive guides
    2. **GitHub Issues**: Search and create issues
    3. **Community Forum**: Ask questions and share knowledge
    4. **Discord/Slack**: Real-time chat support (if available)

    ## Preventive Measures

    ### Code Review Checklist

    - [ ] Domain configurations are valid
    - [ ] Queries have appropriate limits
    - [ ] Error handling is implemented
    - [ ] Tests cover error cases
    - [ ] Performance considerations are addressed

    ### Monitoring Setup

    ```elixir
    # Add to application supervision tree
    {Telemetry.Metrics.ConsoleReporter, metrics: [
      # Database metrics
      summary("my_app.repo.query.total_time"),
      counter("my_app.repo.query.count"),
      
      # Selecto metrics
      summary("selecto.query.duration"),
      counter("selecto.query.error")
    ]}
    ```

    ### Regular Maintenance

    1. **Update dependencies** regularly
    2. **Monitor query performance** in production
    3. **Review and optimize** slow queries
    4. **Check database health** regularly
    5. **Backup configurations** before major changes

    ---

    *Generated by `mix selecto.docs.guide`*
    """
  end

  # Additional guide generation functions would go here...
  defp generate_performance_guide(_opts), do: "# Performance Guide\n\n*Generated by `mix selecto.docs.guide`*"
  defp generate_testing_guide(_opts), do: "# Testing Guide\n\n*Generated by `mix selecto.docs.guide`*"
  defp generate_deployment_guide(_opts), do: "# Deployment Guide\n\n*Generated by `mix selecto.docs.guide`*"
  defp generate_advanced_guide(_opts), do: "# Advanced Guide\n\n*Generated by `mix selecto.docs.guide`*"

  defp generate_generic_guide(guide_type, _opts) do
    title = format_guide_title(guide_type)
    """
    # #{title}

    This guide covers #{String.downcase(title)} for the Selecto ecosystem.

    *Content for this guide is currently being developed.*

    ---

    *Generated by `mix selecto.docs.guide`*
    """
  end

  # HTML generation functions (placeholder)
  defp generate_html_guides_index(_guide_types), do: "<!-- HTML guides index -->"
  defp generate_html_guide(_guide_type, _opts), do: "<!-- HTML guide content -->"
end